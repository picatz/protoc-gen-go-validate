package readme

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"github.com/golang/glog"
	"google.golang.org/protobuf/compiler/protogen"
)

func Generate(pb *protogen.Plugin) error {
	glog.V(0).Infof("Generating README")

	protoPath := "validate/validate.proto"

	file, ok := pb.FilesByPath[protoPath]
	if !ok {
		return fmt.Errorf("failed to get %q in files by path: %#+v", protoPath, pb.FilesByPath)
	}

	readmePath := "README.md"

	fh, err := os.Create(readmePath)
	if err != nil {
		return fmt.Errorf("failed to open or create %q: %w", readmePath, err)
	}
	defer fh.Close()

	glog.V(0).Infof("created %q for writing", readmePath)

	glog.V(0).Infof("trunacting %q", readmePath)
	err = fh.Truncate(0)
	if err != nil {
		return fmt.Errorf("failed to trunace %q: %w", readmePath, err)
	}
	glog.V(0).Infof("seeking to beginning of %q", readmePath)
	_, err = fh.Seek(0, 0)
	if err != nil {
		return fmt.Errorf("failed to seek %q: %w", readmePath, err)
	}

	bw := bufio.NewWriter(fh)
	defer bw.Flush()

	writeLine := func(content string) {
		bw.WriteString(content + "\n")
	}

	writeEmptyLine := func() {
		writeLine("")
	}

	writeHeader := func(level int, header string) {
		writeLine(fmt.Sprintf("%s %s", strings.Repeat("#", level), header))
	}

	writeConsole := func(cmd, output string) {
		writeLine("```console")
		writeLine(fmt.Sprintf("$ %s\n%s", cmd, output))
		writeLine("```")
	}

	// Write the header of the README
	writeLine("<!-- README generated by protoc-gen-go-validate-readme. DO NOT EDIT. -->")
	writeEmptyLine()
	writeHeader(1, "`protoc-gen-go-validate`")
	writeEmptyLine()
	writeLine("Plugin for the Google Protocol Buffers compiler `protoc` that generates common validation code for Golang applications.\n")
	writeEmptyLine()
	writeHeader(2, "Install")
	writeEmptyLine()
	writeConsole("go install github.com/picatz/protoc-gen-go-validate", "...")
	writeEmptyLine()
	writeConsole("make install", "...")
	writeEmptyLine()
	writeHeader(2, "Usage")
	writeEmptyLine()
	writeConsole("protoc -I protos --go_out=. --go-validate_out=. example.proto", "...")
	writeEmptyLine()
	writeLine("> **Note**: you can use the `--go-validate_opt=module=github.com/owner/module` flag when using Go modules.")
	writeEmptyLine()
	writeLine("All validation protobuf options are documented [here](./protos/validate/validate.proto).")
	writeEmptyLine()
	writeHeader(3, "Validate Message Fields")
	writeEmptyLine()
	writeLine("Protobuf message fields can use `(validate.field)` field options.")
	writeEmptyLine()

	glog.V(0).Infof("iterating messages")
	for _, message := range file.Messages {
		// Only generate code for messages with the "Rules" suffix.
		glog.V(0).Infof("message: %v", message.Desc.Name())
		if !strings.HasSuffix(string(message.Desc.Name()), "Rules") {
			glog.V(0).Infof("message: %v is not a rule", message.Desc.Name())
			continue
		}
		glog.V(0).Infof("message: %v is a rule, generating documentation", message.Desc.Name())

		ruleType := strings.TrimSuffix(string(message.Desc.Name()), "Rules")

		// handle the field message differently
		if ruleType != "Field" {
			writeHeader(4, fmt.Sprintf("%s Validation Rules", ruleType))
			writeEmptyLine()
		}

		// Generate doucmentation for each mesage field in the *Rule message.
		for _, field := range message.Fields {
			glog.V(0).Infof("field: %#+v", field.Desc.Name())

			fieldComment := field.Comments.Leading.String()

			fieldCommentParts := strings.Split(fieldComment, "\n")

			for i := range fieldCommentParts {
				fieldCommentParts[i] = strings.TrimPrefix(fieldCommentParts[i], "//")
			}

			// handle the field message differently
			if ruleType == "Field" {
				writeLine(fmt.Sprintf("* `(validate.field).%s`: %s", field.Desc.Name(), fieldCommentParts[0]))
			} else {
				writeLine(fmt.Sprintf("* `%s`: %s", field.Desc.Name(), fieldCommentParts[0]))
			}

			if len(fieldCommentParts) > 1 {
				for i := range fieldCommentParts[1:] {
					if fieldCommentParts[i+1] != "" {
						writeLine(fieldCommentParts[i+1])
					}
				}
			}
		}

		writeEmptyLine()
	}

	return nil
}
