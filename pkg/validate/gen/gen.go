package gen

import (
	"fmt"

	"github.com/golang/glog"
	"github.com/picatz/protoc-gen-go-validate/pkg/validate"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

func Generate(pb *protogen.Plugin) error {
	var (
		log = glog.V(0)
	)
	for _, name := range pb.Request.FileToGenerate {
		f := pb.FilesByPath[name]

		if len(f.Messages) == 0 {
			log.Infof("Skipping %s, no messages", name)
			continue
		}

		fileName := fmt.Sprintf("%s.pb.validate.go", f.GeneratedFilenamePrefix)
		gf := pb.NewGeneratedFile(fileName, f.GoImportPath)

		gf.P("// Code generated by protoc-gen-go-validate. DO NOT EDIT.\n")

		gf.P(fmt.Sprintf("package %s", f.GoPackageName))

		fmtErrorf := gf.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "fmt", GoName: "Errorf"})
		log.Infof("using %v", fmtErrorf)

		for _, msg := range f.Messages {
			// generate validation function for message
			gf.P(`// Validate the message.`)
			gf.P(fmt.Sprintf(`func (x *%s) Validate() error {`, msg.GoIdent.GoName))
			for _, field := range msg.Fields {
				writeFieldValidation(gf, field)
			}
			gf.P(`    return nil // is valid`)
			gf.P(`}`)
			gf.P("")
		}
	}
	return nil

}

func fmtErrorfIdent(gf *protogen.GeneratedFile) string {
	return gf.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "fmt", GoName: "Errorf"})
}

func writeFieldValidation(gf *protogen.GeneratedFile, field *protogen.Field) {
	log := glog.V(0)

	name := field.Desc.Name()
	log.Infof("field: %v", name)

	fOpts, ok := field.Desc.Options().(*descriptorpb.FieldOptions)
	if !ok {
		return
	}

	v := proto.GetExtension(fOpts, validate.E_Field)

	opts, ok := v.(*validate.FieldRules)
	if !ok {
		return
	}

	log.Infof("\toptions: %v", opts)

	if opts == nil {
		return
	}

	if opts.Message != nil {
		if opts.Message.Skip != nil && opts.Message.GetSkip() {
			log.Infof("skipping validation for field %q", name)
			return
		}

		if opts.Message.Required != nil && opts.Message.GetRequired() {
			gf.P(fmt.Sprintf(`    if x.%s == nil {`, field.GoName))
			gf.P(fmt.Sprintf(`        return %s("invalid value for %s, cannot be nil")`, fmtErrorfIdent(gf), field.Desc.Name()))
			gf.P(`                }`)
		}
	}

	switch opts.Type.(type) {
	case *validate.FieldRules_String_:
		rules := opts.GetString_()
		if rules != nil {
			accessName := fmt.Sprintf("x.Get%s()", field.GoName)

			if field.Desc.IsList() {
				gf.P(fmt.Sprintf(`for _, v := range %s {`, accessName))
				accessName = "v"
			}

			if rules.Required != nil && rules.GetRequired() {
				gf.P(fmt.Sprintf(`    if len(%s) == 0 {`, accessName))
				gf.P(fmt.Sprintf(`        return %s("invalid value for %s, cannot be empty")`, fmtErrorfIdent(gf), field.GoName))
				gf.P(`                }`)
			}

			//if field.Desc.HasOptionalKeyword() {
			//	gf.P(fmt.Sprintf(`    if x.%s != nil {`, field.GoName))
			//	accessName = fmt.Sprintf("x.Get%s()", field.GoName)
			//}

			if rules.Len != nil {
				gf.P(fmt.Sprintf(`    if len(%s) != %d {`, accessName, rules.GetLen()))
				gf.P(fmt.Sprintf(`        return %s("invalid length for %s, must be %d")`, fmtErrorfIdent(gf), field.GoName, rules.GetLen()))
				gf.P(`                }`)
			}
			if rules.Gt != nil {
				gf.P(fmt.Sprintf(`    if len(%s) <= %d {`, accessName, rules.GetGt()))
				gf.P(fmt.Sprintf(`        return %s("invalid length for %s, must be greater than %d")`, fmtErrorfIdent(gf), field.GoName, rules.GetGt()))
				gf.P(`                }`)
			}
			if rules.Lt != nil {
				gf.P(fmt.Sprintf(`    if len(%s) >= %d {`, accessName, rules.GetLt()))
				gf.P(fmt.Sprintf(`        return %s("invalid length for %s, must be less than %d")`, fmtErrorfIdent(gf), field.GoName, rules.GetLt()))
				gf.P(`                }`)
			}
			if rules.Min != nil {
				gf.P(fmt.Sprintf(`    if len(%s) < %d {`, accessName, rules.GetMin()))
				gf.P(fmt.Sprintf(`        return %s("invalid length for %s, must be at least %d")`, fmtErrorfIdent(gf), field.GoName, rules.GetMin()))
				gf.P(`                }`)
			}
			if rules.Max != nil {
				gf.P(fmt.Sprintf(`    if len(%s) > %d {`, accessName, rules.GetMax()))
				gf.P(fmt.Sprintf(`        return %s("invalid length for %s, cannot be more than %d")`, fmtErrorfIdent(gf), field.GoName, rules.GetMax()))
				gf.P(`                }`)
			}
			if rules.Contains != nil {
				stringContains := gf.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "strings", GoName: "Contains"})

				gf.P(fmt.Sprintf(`    if !%s(%s, %q) {`, stringContains, accessName, rules.GetContains()))

				msg := fmt.Sprintf("invalid value for %s, must contain %q", field.GoName, rules.GetContains())
				gf.P(fmt.Sprintf(`        return %s(%q)`, fmtErrorfIdent(gf), msg))
				gf.P(`                }`)
			}
			if rules.NotContains != nil {
				stringContains := gf.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "strings", GoName: "Contains"})

				gf.P(fmt.Sprintf(`    if %s(%s, %q) {`, stringContains, accessName, rules.GetNotContains()))
				msg := fmt.Sprintf("invalid value for %s, must not contain %q", field.GoName, rules.GetNotContains())
				gf.P(fmt.Sprintf(`        return %s(%q)`, fmtErrorfIdent(gf), msg))
				gf.P(`                }`)
			}
			if rules.Prefix != nil {
				stringHasPrefix := gf.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "strings", GoName: "HasPrefix"})
				gf.P(fmt.Sprintf(`    if !%s(%s, %q) {`, stringHasPrefix, accessName, rules.GetPrefix()))
				msg := fmt.Sprintf("invalid value for %s, must have prefix %q", field.GoName, rules.GetPrefix())
				gf.P(fmt.Sprintf(`        return %s(%q)`, fmtErrorfIdent(gf), msg))
				gf.P(`                }`)
			}
			if rules.Suffix != nil {
				stringHasSuffix := gf.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "strings", GoName: "HasSuffix"})
				gf.P(fmt.Sprintf(`    if !%s(%s, %q) {`, stringHasSuffix, accessName, rules.GetSuffix()))
				msg := fmt.Sprintf("invalid value for %s, must have suffix %q", field.GoName, rules.GetSuffix())
				gf.P(fmt.Sprintf(`        return %s(%q)`, fmtErrorfIdent(gf), msg))
				gf.P(`                }`)
			}
			if rules.AllowSpace != nil && !rules.GetAllowSpace() {
				stringContains := gf.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "strings", GoName: "Contains"})

				gf.P(fmt.Sprintf(`    if %s(%s, " ") {`, stringContains, accessName))
				msg := fmt.Sprintf("invalid value for %s, cannot have spaces", field.GoName)
				gf.P(fmt.Sprintf(`        return %s(%q)`, fmtErrorfIdent(gf), msg))
				gf.P(`                }`)
			}
			if rules.GetAsciiOnly() {
				gf.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "unicode"})
				gf.P(fmt.Sprintf(`    for _, c := range %s {`, accessName))
				gf.P(`                    if c > unicode.MaxASCII {`)
				msg := fmt.Sprintf("invalid value for %s, can only contain ASCII characters", field.GoName)
				gf.P(fmt.Sprintf(`            return %s(%q)`, fmtErrorfIdent(gf), msg))
				gf.P(`                    }`)
				gf.P(`                }`)
			}
			if rules.Match != nil {
				gf.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "regexp"})
				gf.P(fmt.Sprintf(`    match%s, err := regexp.Match(%q, []byte(%s))`, field.GoName, rules.GetMatch(), accessName))
				gf.P(`                if err != nil {`)
				gf.P(`                    return fmt.Errorf("failed to validate: %w", err)`)
				gf.P(`                }`)
				gf.P(fmt.Sprintf(`                if !match%s {`, field.GoName))
				msg := fmt.Sprintf("invalid value for %s, did not match %q", field.GoName, rules.GetMatch())
				gf.P(fmt.Sprintf(`            return %s(%q)`, fmtErrorfIdent(gf), msg))
				gf.P(`                }`)
			}
			if rules.NotMatch != nil {
				gf.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "regexp"})
				gf.P(fmt.Sprintf(`    notMatch%s, err := regexp.Match(%q, []byte(%s))`, field.GoName, rules.GetNotMatch(), accessName))
				gf.P(`                if err != nil {`)
				gf.P(`                    return fmt.Errorf("failed to validate: %w", err)`)
				gf.P(`                }`)
				gf.P(fmt.Sprintf(`                if notMatch%s {`, field.GoName))
				msg := fmt.Sprintf("invalid value for %s, can not match %q", field.GoName, rules.GetNotMatch())
				gf.P(fmt.Sprintf(`            return %s(%q)`, fmtErrorfIdent(gf), msg))
				gf.P(`                }`)
			}
			if field.Desc.IsList() {
				gf.P(`}`)
			}
			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(`                }`)
			// }
		}
	case *validate.FieldRules_Bytes:
		rules := opts.GetBytes()

		if rules != nil {
			accessName := fmt.Sprintf("x.Get%s()", field.GoName)

			if field.Desc.IsList() {
				gf.P(fmt.Sprintf(`for _, v := range %s {`, accessName))
				accessName = "v"
			}

			if rules.Required != nil && rules.GetRequired() {
				gf.P(fmt.Sprintf(`    if x.Get%s() == nil {`, field.GoName))
				gf.P(fmt.Sprintf(`        return %s("invalid value for %s, is required")`, fmtErrorfIdent(gf), field.GoName))
				gf.P(`                }`)
			}

			if field.Desc.HasOptionalKeyword() {
				gf.P(fmt.Sprintf(`    if %s != nil {`, accessName))
				accessName = fmt.Sprintf("x.Get%s()", field.GoName)
			}

			if rules.Len != nil {
				val := rules.GetLen()
				expr := fmt.Sprintf(`len(%s) != %d`, accessName, val)
				errMsg := fmt.Sprintf("must equal %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gt != nil {
				val := rules.GetGt()
				expr := fmt.Sprintf(`len(%s) <= %d`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gte != nil {
				val := rules.GetGte()
				expr := fmt.Sprintf(`len(%s) < %d`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than or equal to %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lt != nil {
				val := rules.GetLt()
				expr := fmt.Sprintf(`len(%s) >= %d`, accessName, val)
				errMsg := fmt.Sprintf("must be less than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lte != nil {
				val := rules.GetLte()
				expr := fmt.Sprintf(`len(%s) > %d`, accessName, val)
				errMsg := fmt.Sprintf("must be less than or equal to %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Min != nil {
				val := rules.GetMin()
				expr := fmt.Sprintf(`len(%s) > %d`, accessName, val)
				errMsg := fmt.Sprintf("must be at least %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Max != nil {
				val := rules.GetMax()
				expr := fmt.Sprintf(`len(%s) < %d`, accessName, val)
				errMsg := fmt.Sprintf("cannot be greater than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Prefix != nil {
				val := rules.GetPrefix()
				expr := fmt.Sprintf(`strings.HasPrefix(string(%s), %q)`, accessName, val)
				errMsg := fmt.Sprintf("must have prefix %q", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Suffix != nil {
				val := rules.GetSuffix()
				expr := fmt.Sprintf(`strings.HasSuffix(string(%s), %q)`, accessName, val)
				errMsg := fmt.Sprintf("must have suffix %q", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Required != nil {
				val := rules.GetRequired()
				if val {
					expr := fmt.Sprintf("len(%s) == 0", accessName)
					errMsg := "must use non-empty value"
					writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
				}
			}

			if field.Desc.IsList() {
				gf.P(`}`)
			}

			if field.Desc.HasOptionalKeyword() {
				gf.P(`                }`)
			}
		}
	case *validate.FieldRules_Uint32:
		rules := opts.GetUint32()

		if rules != nil {
			accessName := fmt.Sprintf("x.Get%s()", field.GoName)

			if field.Desc.IsList() {
				gf.P(fmt.Sprintf(`for _, v := range %s {`, accessName))
				accessName = "v"
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(fmt.Sprintf(`    if %s != nil {`, accessName))
			// 	accessName = fmt.Sprintf("x.Get%s()", field.GoName)
			// }

			if rules.Eq != nil {
				val := rules.GetEq()
				expr := fmt.Sprintf(`%s != %d`, accessName, val)
				errMsg := fmt.Sprintf("must equal %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gt != nil {
				val := rules.GetGt()
				expr := fmt.Sprintf(`%s <= %d`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gte != nil {
				val := rules.GetGte()
				expr := fmt.Sprintf(`%s < %d`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than or equal to %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lt != nil {
				val := rules.GetLt()
				expr := fmt.Sprintf(`%s >= %d`, accessName, val)
				errMsg := fmt.Sprintf("must be less than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lte != nil {
				val := rules.GetLte()
				expr := fmt.Sprintf(`%s > %d`, accessName, val)
				errMsg := fmt.Sprintf("must be less than or equal to %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Min != nil {
				val := rules.GetMin()
				expr := fmt.Sprintf(`%s > %d`, accessName, val)
				errMsg := fmt.Sprintf("must be at least %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Max != nil {
				val := rules.GetMax()
				expr := fmt.Sprintf(`%s < %d`, accessName, val)
				errMsg := fmt.Sprintf("cannot be greater than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Required != nil {
				val := rules.GetRequired()
				if val {
					expr := fmt.Sprintf(`%s == 0`, accessName)
					errMsg := "must use non-zero value"
					writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
				}
			}

			if field.Desc.IsList() {
				gf.P(`}`)
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(`                }`)
			// }
		}
	case *validate.FieldRules_Int32:
		rules := opts.GetInt32()

		if rules != nil {
			accessName := fmt.Sprintf("x.Get%s()", field.GoName)

			if field.Desc.IsList() {
				gf.P(fmt.Sprintf(`for _, v := range %s {`, accessName))
				accessName = "v"
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(fmt.Sprintf(`    if %s != nil {`, accessName))
			// 	accessName = fmt.Sprintf("x.Get%s()", field.GoName)
			// }

			if rules.Eq != nil {
				val := rules.GetEq()
				expr := fmt.Sprintf(`%s != %d`, accessName, val)
				errMsg := fmt.Sprintf("must equal %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gt != nil {
				val := rules.GetGt()
				expr := fmt.Sprintf(`%s <= %d`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gte != nil {
				val := rules.GetGte()
				expr := fmt.Sprintf(`%s < %d`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than or equal to %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lt != nil {
				val := rules.GetLt()
				expr := fmt.Sprintf(`%s >= %d`, accessName, val)
				errMsg := fmt.Sprintf("must be less than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lte != nil {
				val := rules.GetLte()
				expr := fmt.Sprintf(`%s > %d`, accessName, val)
				errMsg := fmt.Sprintf("must be less than or equal to %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Min != nil {
				val := rules.GetMin()
				expr := fmt.Sprintf(`%s > %d`, accessName, val)
				errMsg := fmt.Sprintf("must be at least %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Max != nil {
				val := rules.GetMax()
				expr := fmt.Sprintf(`%s < %d`, accessName, val)
				errMsg := fmt.Sprintf("cannot be greater than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Required != nil {
				val := rules.GetRequired()
				if val {
					expr := fmt.Sprintf(`%s == 0`, accessName)
					errMsg := "must use non-zero value"
					writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
				}
			}

			if field.Desc.IsList() {
				gf.P(`}`)
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(`                }`)
			// }
		}
	case *validate.FieldRules_Uint64:
		rules := opts.GetUint64()

		if rules != nil {
			accessName := fmt.Sprintf("x.Get%s()", field.GoName)

			if field.Desc.IsList() {
				gf.P(fmt.Sprintf(`for _, v := range %s {`, accessName))
				accessName = "v"
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(fmt.Sprintf(`    if %s != nil {`, accessName))
			// 	accessName = fmt.Sprintf("x.Get%s()", field.GoName)
			// }

			if rules.Eq != nil {
				val := rules.GetEq()
				expr := fmt.Sprintf(`%s != %d`, accessName, val)
				errMsg := fmt.Sprintf("must equal %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gt != nil {
				val := rules.GetGt()
				expr := fmt.Sprintf(`%s <= %d`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gte != nil {
				val := rules.GetGte()
				expr := fmt.Sprintf(`%s < %d`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than or equal to %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lt != nil {
				val := rules.GetLt()
				expr := fmt.Sprintf(`%s >= %d`, accessName, val)
				errMsg := fmt.Sprintf("must be less than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lte != nil {
				val := rules.GetLte()
				expr := fmt.Sprintf(`%s > %d`, accessName, val)
				errMsg := fmt.Sprintf("must be less than or equal to %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Min != nil {
				val := rules.GetMin()
				expr := fmt.Sprintf(`%s > %d`, accessName, val)
				errMsg := fmt.Sprintf("must be at least %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Max != nil {
				val := rules.GetMax()
				expr := fmt.Sprintf(`%s < %d`, accessName, val)
				errMsg := fmt.Sprintf("cannot be greater than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Required != nil {
				val := rules.GetRequired()
				if val {
					expr := fmt.Sprintf(`%s == 0`, accessName)
					errMsg := "must use non-zero value"
					writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
				}
			}

			if field.Desc.IsList() {
				gf.P(`}`)
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(`                }`)
			// }
		}
	case *validate.FieldRules_Int64:
		rules := opts.GetInt64()

		if rules != nil {
			accessName := fmt.Sprintf("x.Get%s()", field.GoName)

			if field.Desc.IsList() {
				gf.P(fmt.Sprintf(`for _, v := range %s {`, accessName))
				accessName = "v"
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(fmt.Sprintf(`    if %s != nil {`, accessName))
			// 	accessName = fmt.Sprintf("x.Get%s()", field.GoName)
			// }

			if rules.Eq != nil {
				val := rules.GetEq()
				expr := fmt.Sprintf(`%s != %d`, accessName, val)
				errMsg := fmt.Sprintf("must equal %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gt != nil {
				val := rules.GetGt()
				expr := fmt.Sprintf(`%s <= %d`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gte != nil {
				val := rules.GetGte()
				expr := fmt.Sprintf(`%s < %d`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than or equal to %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lt != nil {
				val := rules.GetLt()
				expr := fmt.Sprintf(`%s >= %d`, accessName, val)
				errMsg := fmt.Sprintf("must be less than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lte != nil {
				val := rules.GetLte()
				expr := fmt.Sprintf(`%s > %d`, accessName, val)
				errMsg := fmt.Sprintf("must be less than or equal to %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Min != nil {
				val := rules.GetMin()
				expr := fmt.Sprintf(`%s > %d`, accessName, val)
				errMsg := fmt.Sprintf("must be at least %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Max != nil {
				val := rules.GetMax()
				expr := fmt.Sprintf(`%s < %d`, accessName, val)
				errMsg := fmt.Sprintf("cannot be greater than %d", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Required != nil {
				val := rules.GetRequired()
				if val {
					expr := fmt.Sprintf(`%s == 0`, accessName)
					errMsg := "must use non-zero value"
					writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
				}
			}

			if field.Desc.IsList() {
				gf.P(`}`)
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(`                }`)
			// }
		}
	case *validate.FieldRules_Float:
		rules := opts.GetFloat()

		if rules != nil {
			accessName := fmt.Sprintf("x.Get%s()", field.GoName)

			if field.Desc.IsList() {
				gf.P(fmt.Sprintf(`for _, v := range %s {`, accessName))
				accessName = "v"
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(fmt.Sprintf(`    if %s != nil {`, accessName))
			// 	accessName = fmt.Sprintf("x.Get%s()", field.GoName)
			// }

			if rules.Eq != nil {
				val := rules.GetEq()
				expr := fmt.Sprintf(`%s != %f`, accessName, val)
				errMsg := fmt.Sprintf("must equal %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gt != nil {
				val := rules.GetGt()
				expr := fmt.Sprintf(`%s <= %f`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gte != nil {
				val := rules.GetGte()
				expr := fmt.Sprintf(`%s < %f`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than or equal to %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lt != nil {
				val := rules.GetLt()
				expr := fmt.Sprintf(`%s >= %f`, accessName, val)
				errMsg := fmt.Sprintf("must be less than %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lte != nil {
				val := rules.GetLte()
				expr := fmt.Sprintf(`%s > %f`, accessName, val)
				errMsg := fmt.Sprintf("must be less than or equal to %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Min != nil {
				val := rules.GetMin()
				expr := fmt.Sprintf(`%s > %f`, accessName, val)
				errMsg := fmt.Sprintf("must be at least %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Max != nil {
				val := rules.GetMax()
				expr := fmt.Sprintf(`%s < %f`, accessName, val)
				errMsg := fmt.Sprintf("cannot be greater than %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Required != nil {
				val := rules.GetRequired()
				if val {
					expr := fmt.Sprintf(`%s == 0`, accessName)
					errMsg := "must use non-zero value"
					writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
				}
			}

			if field.Desc.IsList() {
				gf.P(`}`)
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(`                }`)
			// }
		}
	case *validate.FieldRules_Double:
		rules := opts.GetDouble()

		if rules != nil {
			accessName := fmt.Sprintf("x.Get%s()", field.GoName)

			if field.Desc.IsList() {
				gf.P(fmt.Sprintf(`for _, v := range %s {`, accessName))
				accessName = "v"
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(fmt.Sprintf(`    if %s != nil {`, accessName))
			// 	accessName = fmt.Sprintf("x.Get%s()", field.GoName)
			// }

			if rules.Eq != nil {
				val := rules.GetEq()
				expr := fmt.Sprintf(`%s != %f`, accessName, val)
				errMsg := fmt.Sprintf("must equal %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gt != nil {
				val := rules.GetGt()
				expr := fmt.Sprintf(`%s <= %f`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Gte != nil {
				val := rules.GetGte()
				expr := fmt.Sprintf(`%s < %f`, accessName, val)
				errMsg := fmt.Sprintf("must be greater than or equal to %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lt != nil {
				val := rules.GetLt()
				expr := fmt.Sprintf(`%s >= %f`, accessName, val)
				errMsg := fmt.Sprintf("must be less than %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Lte != nil {
				val := rules.GetLte()
				expr := fmt.Sprintf(`%s > %f`, accessName, val)
				errMsg := fmt.Sprintf("must be less than or equal to %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Min != nil {
				val := rules.GetMin()
				expr := fmt.Sprintf(`%s > %f`, accessName, val)
				errMsg := fmt.Sprintf("must be at least %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Max != nil {
				val := rules.GetMax()
				expr := fmt.Sprintf(`%s < %f`, accessName, val)
				errMsg := fmt.Sprintf("cannot be greater than %f", val)
				writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
			}

			if rules.Required != nil {
				val := rules.GetRequired()
				if val {
					expr := fmt.Sprintf(`%s == 0`, accessName)
					errMsg := "must use non-zero value"
					writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
				}
			}

			if field.Desc.IsList() {
				gf.P(`}`)
			}

			// if field.Desc.HasOptionalKeyword() {
			// 	gf.P(`                }`)
			// }
		}
	case *validate.FieldRules_Repeated:
		rules := opts.GetRepeated()

		if rules == nil {
			return
		}

		if rules.Min != nil {
			val := rules.GetMin()
			expr := fmt.Sprintf(`len(x.Get%s()) < %d`, field.GoName, val)
			errMsg := fmt.Sprintf("must have at least %d items", val)
			writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
		}

		if rules.Max != nil {
			val := rules.GetMax()
			expr := fmt.Sprintf(`len(x.Get%s()) > %d`, field.GoName, val)
			errMsg := fmt.Sprintf("cannot have more than %d items", val)
			writeFieldValidationExpr(gf, field.GoName, expr, errMsg)
		}

		// ruleItems := rules.GetItems()
		// if ruleItems != nil {
		// 	switch ruleItems.GetType().(type) {
		// 	case *validate.FieldRules_String_:

		// TODO: implement this (rules.Items)
	default:
		// temporary hack
		if field.Desc.Kind().String() != "message" {
			log.Infof("unhandled validation type: %T for field %q of kind %q", opts.Type, field.Desc.Name(), field.Desc.Kind())
		}
		return
	}
}

func writeFieldValidationExpr(gf *protogen.GeneratedFile, field, expr, errMsg string) {
	gf.P(fmt.Sprintf(`    if %s {`, expr))
	errMsg = fmt.Sprintf("invalid value for %s, %s", field, errMsg)
	gf.P(fmt.Sprintf(`        return %s(%q)`, fmtErrorfIdent(gf), errMsg))
	gf.P(`                }`)

}
